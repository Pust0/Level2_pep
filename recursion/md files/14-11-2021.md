## 1. Cryptarithmetic

```java
public static int getNum(String s, HashMap<Character, Integer> charIntMap){
        String num="";
        for(int i=0; i<s.length(); ++i)
            num+=charIntMap.get(s.charAt(i));
        return Integer.parseInt(num);
    }

  public static void solution(String unique, int idx, HashMap<Character, Integer> charIntMap, boolean[] usedNumbers, String s1, String s2, String s3) {
    if(idx==unique.length()){
        int num1=getNum(s1, charIntMap);
        int num2=getNum(s2, charIntMap);
        int num3=getNum(s3, charIntMap);

        if(num1+num2==num3){
            for(int i=0; i<26; ++i){
                char ch=(char)('a'+i);
                if(charIntMap.containsKey(ch)){
                    System.out.print(ch+"-"+charIntMap.get(ch)+" ");
                }
            }
            System.out.println();
        }
        return;
    }

    char ch=unique.charAt(idx);
    for(int num=0; num<=9; ++num){
        if(!usedNumbers[num]){
            usedNumbers[num]=true;
            charIntMap.put(ch, num);
            solution(unique, idx+1, charIntMap, usedNumbers, s1, s2, s3);
            usedNumbers[num]=false;
            charIntMap.put(ch, -1);
        }
    }
}
```

## 2. Marks of PCM

```cpp
//code
#include<iostream>
#include<vector>
#include<bits/stdc++.h>
using namespace std;
class marks{
    public:
        int phy=0;
        int chem=0;
        int math=0;
        
        marks() {
            
        }
        
        marks(int phy,int chem,int math) {
            this->phy=phy;
            this->chem=chem;
            this->math=math;
        }
    };
    
class compare{
    public:
    bool operator()(marks& a, marks& b){
        if(a.phy!=b.phy){
                return a.phy<b.phy;
            }else if(a.chem!=b.chem){
                return a.chem>b.chem;
            }else{
                return a.math<b.math;
            }
    }
};



void customSort(vector<int> &phy, vector<int> &chem, vector<int> &math){
        int N = phy.size();
        vector<marks> arr;
        
        for(int i=0; i < N;i++) {
            marks m={phy[i],chem[i],math[i]};
            arr.push_back(m);
        }
        
        sort(arr.begin(),arr.end(),compare());
        
        for(int i=0; i < N;i++) {
            phy[i] = arr[i].phy;
            chem[i] = arr[i].chem;
            math[i] = arr[i].math;
        }
}

int main(){
    int n;
    cin>>n;
    vector<int> phy(n,0), chem(n,0), math(n,0);
    
    for(int i=0; i<n; ++i){
        cin>>phy[i];
    }
    for(int i=0; i<n; ++i){
        cin>>chem[i];
    }
    for(int i=0; i<n; ++i){
        cin>>math[i];
    }
    
    customSort(phy, chem, math);
    
    for(int i=0; i<n; ++i){
        cout<<phy[i]<<" "<<chem[i]<<" "<<math[i]<<endl;
    }
    
    return 0;
}
```


## 3. Find K closest elements
```cpp
#include<bits/stdc++.h>

using namespace std;

class Pair{
    public:
    int val=0;
    int gap=0;
    
    Pair(){
        
    }
    
    Pair(int val, int gap){
        this->val=val;
        this->gap=gap;
    }
};

vector<int> findClosest(vector<int> &arr, int k, int x){
    vector<int> list;
    priority_queue<Pair, vector<int>> pq;
    
    for(int i=0; i<arr.size(); ++i){
        if(pq.size()<k){
            Pair m={arr[i], abs(arr[i]-x)};
            pq.push(m);
        }else{
            if(pq.top().gap>abs(arr[i]-x)){
                pq.pop();
                Pair m={arr[i], abs(arr[i]-x)};
                pq.push(m);
            }
        }
    }
    
    while(pq.size()>0){
        list.add(pq.pop().val);
    }
    
    sort(list.begin(), list.end());
    
    return list;
}

int main(){
    int n;
    cin>>n;
    vector<int> arr;
    
    for(int i=0; i<n; ++i){
        int a;
        cin>>a;
        arr.push_back(a);
    }
    
    int k, x;
    cin>>k>>x;
    
    vector<int> ans=findClosest(arr, k, x);
    
    for(int ele: ans){
        cout<<ele<<" ";
    }
    
    return 0;
}
```
